diff --git a/CMakeLists.txt b/CMakeLists.txt
index 460eb83..cf922cf 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -186,6 +186,60 @@ include(FetchContent)
 include(Helper)
 include(GNUInstallDirs)
 
+# When building under Bazel with rules_foreign_cc, dependencies are provided via EXT_BUILD_DEPS
+# EXT_BUILD_DEPS environment variable contains the path to the merged dependency directory
+# created by rules_foreign_cc, with headers in include/ and libraries in lib/
+# All dependencies listed in the cmake() rule's deps attribute are merged into a single directory structure
+# Create IMPORTED targets for fmt and spdlog to prevent CMake FetchContent from trying to download them
+if(DEFINED ENV{EXT_BUILD_DEPS})
+  set(BAZEL_EXT_BUILD_DEPS "$ENV{EXT_BUILD_DEPS}")
+  set(BAZEL_BUILD ON)
+  message(STATUS "Bazel build detected, using dependencies from: ${BAZEL_EXT_BUILD_DEPS}")
+  
+  # Create fmt::fmt IMPORTED target
+  # fmt is a library with compiled sources (not header-only)
+  if(NOT TARGET fmt::fmt AND EXISTS "${BAZEL_EXT_BUILD_DEPS}/include/fmt")
+    # Look for the fmt library file
+    find_library(FMT_LIBRARY
+      NAMES fmt libfmt
+      PATHS "${BAZEL_EXT_BUILD_DEPS}/lib"
+      NO_DEFAULT_PATH
+    )
+    
+    if(FMT_LIBRARY)
+      # Create STATIC IMPORTED library
+      add_library(fmt::fmt STATIC IMPORTED)
+      set_target_properties(fmt::fmt PROPERTIES
+        IMPORTED_LOCATION "${FMT_LIBRARY}"
+        INTERFACE_INCLUDE_DIRECTORIES "${BAZEL_EXT_BUILD_DEPS}/include"
+      )
+      message(STATUS "Created fmt::fmt IMPORTED target from Bazel deps: ${FMT_LIBRARY}")
+    else()
+      message(WARNING "fmt headers found at ${BAZEL_EXT_BUILD_DEPS}/include/fmt but compiled library not found in ${BAZEL_EXT_BUILD_DEPS}/lib. Check that fmt dependency is properly configured in Bazel BUILD file.")
+    endif()
+    
+    # Create non-namespaced alias for backward compatibility with code that references fmt without the namespace
+    if(TARGET fmt::fmt)
+      add_library(fmt ALIAS fmt::fmt)
+    endif()
+  endif()
+  
+  # Create spdlog::spdlog IMPORTED target
+  # spdlog is header-only when using external fmt
+  if(NOT TARGET spdlog::spdlog AND EXISTS "${BAZEL_EXT_BUILD_DEPS}/include/spdlog")
+    add_library(spdlog::spdlog INTERFACE IMPORTED)
+    set_target_properties(spdlog::spdlog PROPERTIES
+      INTERFACE_INCLUDE_DIRECTORIES "${BAZEL_EXT_BUILD_DEPS}/include"
+      INTERFACE_COMPILE_DEFINITIONS "SPDLOG_FMT_EXTERNAL"
+    )
+    # spdlog depends on fmt
+    if(TARGET fmt::fmt)
+      set_property(TARGET spdlog::spdlog APPEND PROPERTY INTERFACE_LINK_LIBRARIES fmt::fmt)
+    endif()
+    message(STATUS "Created spdlog::spdlog IMPORTED target from Bazel deps")
+  endif()
+endif()
+
 set(CPACK_PACKAGE_VENDOR Second State LLC)
 set(CPACK_PACKAGE_FILE_NAME "${CMAKE_PROJECT_NAME}-${CPACK_PACKAGE_VERSION}-${CMAKE_SYSTEM_NAME}")
 set(CPACK_STRIP_FILES ON)
diff --git a/cmake/Helper.cmake b/cmake/Helper.cmake
index d3ea6d6..871e607 100644
--- a/cmake/Helper.cmake
+++ b/cmake/Helper.cmake
@@ -214,9 +214,35 @@ endfunction()
 # Generate the list of static libs to statically link LLVM.
 if((WASMEDGE_LINK_LLVM_STATIC OR WASMEDGE_BUILD_STATIC_LIB) AND WASMEDGE_USE_LLVM)
   # Pack the LLVM and lld static libraries.
+  # When building with Bazel, generate LLVM CMake config files directly
+  # This avoids the need for tarball extraction which can have cross-configuration dependency issues
+  if(BAZEL_BUILD AND DEFINED ENV{EXT_BUILD_DEPS})
+    set(LLVM_CMAKE_DIR "$ENV{EXT_BUILD_DEPS}/llvm_cmake/lib/cmake/llvm")
+    
+    # First try to extract tarball if it exists (fallback for compatibility)
+    set(LLVM_CMAKE_TARBALL "$ENV{EXT_BUILD_DEPS}/llvm_cmake.tar.gz")
+    if(EXISTS "${LLVM_CMAKE_TARBALL}")
+      message(STATUS "Bazel build: Extracting LLVM CMake config from ${LLVM_CMAKE_TARBALL}")
+      execute_process(
+        COMMAND ${CMAKE_COMMAND} -E tar xzf "${LLVM_CMAKE_TARBALL}"
+        WORKING_DIRECTORY "$ENV{EXT_BUILD_DEPS}"
+        RESULT_VARIABLE EXTRACT_RESULT
+        OUTPUT_VARIABLE EXTRACT_OUTPUT
+        ERROR_VARIABLE EXTRACT_ERROR
+      )
+      if(NOT EXTRACT_RESULT EQUAL 0)
+        message(FATAL_ERROR "Failed to extract LLVM CMake config: ${EXTRACT_ERROR}")
+      endif()
+      message(STATUS "Bazel build: LLVM CMake config extracted successfully")
+    elseif(NOT EXISTS "${LLVM_CMAKE_DIR}/LLVMConfig.cmake")
+      # Tarball not found, generate CMake config files directly
+      message(STATUS "Bazel build: Generating LLVM CMake config files at ${LLVM_CMAKE_DIR}")
+      file(MAKE_DIRECTORY "${LLVM_CMAKE_DIR}")
+      
+      # Determine native architecture
+      if(CMAKE_SYSTEM_PROCESSOR MATCHES "aarch64|arm64|ARM64")
+        set(LLVM_NATIVE_ARCH "AArch64")
+      elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "x86_64|amd64|AMD64")
+        set(LLVM_NATIVE_ARCH "X86")
+      else()
+        set(LLVM_NATIVE_ARCH "X86")  # Default fallback
+      endif()
+      
+      # Create LLVMConfig.cmake
+      file(WRITE "${LLVM_CMAKE_DIR}/LLVMConfig.cmake" "
+# Minimal LLVMConfig.cmake for Bazel builds
+# Generated by WasmEdge CMake during configuration
+
+set(LLVM_VERSION_MAJOR 19)
+set(LLVM_VERSION_MINOR 1)
+set(LLVM_VERSION_PATCH 0)
+set(LLVM_VERSION_SUFFIX \"\")
+set(LLVM_VERSION_STRING \"19.1.0\")
+
+# Set library and include directories
+get_filename_component(LLVM_INSTALL_PREFIX \"\${CMAKE_CURRENT_LIST_DIR}/../../..\" ABSOLUTE)
+set(LLVM_LIBRARY_DIR \"\${LLVM_INSTALL_PREFIX}/lib\")
+set(LLVM_CMAKE_DIR \"\${CMAKE_CURRENT_LIST_DIR}\")
+set(LLVM_INCLUDE_DIRS \"\${LLVM_INSTALL_PREFIX}/include\")
+set(LLVM_DEFINITIONS \"\")
+set(LLVM_ENABLE_ASSERTIONS OFF)
+set(LLVM_ENABLE_EH OFF)
+set(LLVM_ENABLE_RTTI OFF)
+set(LLVM_BUILD_TYPE \"Release\")
+
+# Target information
+set(LLVM_TARGETS_TO_BUILD \"X86;AArch64\")
+set(LLVM_NATIVE_ARCH ${LLVM_NATIVE_ARCH})
+
+# Components (minimal set for WasmEdge)
+set(LLVM_AVAILABLE_LIBS \"\")
+
+# Mark as found
+set(LLVM_FOUND TRUE)
+
+# Include LLVMExports if it exists (it will be empty but needs to exist)
+include(\"\${CMAKE_CURRENT_LIST_DIR}/LLVMExports.cmake\" OPTIONAL)
+
+message(STATUS \"Found LLVM \${LLVM_VERSION_STRING} (Bazel-generated config)\")
+message(STATUS \"LLVM_CMAKE_DIR: \${LLVM_CMAKE_DIR}\")
+message(STATUS \"LLVM_LIBRARY_DIR: \${LLVM_LIBRARY_DIR}\")
+message(STATUS \"LLVM_INCLUDE_DIRS: \${LLVM_INCLUDE_DIRS}\")
+")
+      
+      # Create LLVMConfigVersion.cmake
+      file(WRITE "${LLVM_CMAKE_DIR}/LLVMConfigVersion.cmake" "
+# LLVMConfigVersion.cmake for Bazel builds
+set(PACKAGE_VERSION \"19.1.0\")
+set(PACKAGE_VERSION_EXACT FALSE)
+set(PACKAGE_VERSION_COMPATIBLE TRUE)
+if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)
+  set(PACKAGE_VERSION_COMPATIBLE FALSE)
+endif()
+if(PACKAGE_FIND_VERSION_MAJOR STREQUAL \"19\" AND 
+   PACKAGE_FIND_VERSION_MINOR STREQUAL \"1\")
+  set(PACKAGE_VERSION_EXACT TRUE)
+endif()
+")
+      
+      # Create empty LLVMExports.cmake
+      file(WRITE "${LLVM_CMAKE_DIR}/LLVMExports.cmake" "
+# LLVMExports.cmake for Bazel builds
+# In Bazel builds, LLVM libraries are linked via cc_library deps,
+# not via CMake targets, so this file is intentionally minimal.
+")
+      
+      message(STATUS "Bazel build: LLVM CMake config files generated successfully")
+    else()
+      message(STATUS "Bazel build: LLVM CMake config files already exist at ${LLVM_CMAKE_DIR}")
+    endif()
+  endif()
+  # When building with Bazel, skip LLD entirely - Bazel provides LLVM via llvm-project
   find_package(LLVM REQUIRED HINTS "${LLVM_DIR}")
-  find_package(LLD HINTS "${LLVM_DIR}" "${LLD_DIR}")
-  if(LLD_FOUND)
+  if(NOT BAZEL_BUILD)
+    find_package(LLD HINTS "${LLVM_DIR}" "${LLD_DIR}")
+  else()
+    message(STATUS "Bazel build: Skipping LLD libraries (LLVM provided via Bazel llvm-project)")
+  endif()
+  if(LLD_FOUND AND NOT BAZEL_BUILD)
     get_property(LLD_LIBRARY_DIR TARGET lldELF PROPERTY IMPORTED_LOCATION_RELEASE)
     get_filename_component(LLD_LIBRARY_DIR "${LLD_LIBRARY_DIR}" DIRECTORY)
   endif()
@@ -233,10 +259,14 @@ if((WASMEDGE_LINK_LLVM_STATIC OR WASMEDGE_BUILD_STATIC_LIB) AND WASMEDGE_USE_LLV
   string(REPLACE " " ";" WASMEDGE_LLVM_LINK_LIBS_NAME "${WASMEDGE_LLVM_LINK_LIBS_NAME}")
   set(WASMEDGE_LLVM_LINK_LIBS_NAME "${WASMEDGE_LLVM_LINK_LIBS_NAME}")
 
-  list(APPEND WASMEDGE_LLVM_LINK_STATIC_COMPONENTS
-    ${LLD_LIBRARY_DIR}/liblldELF.a
-    ${LLD_LIBRARY_DIR}/liblldCommon.a
-  )
+  # Skip LLD libraries when building with Bazel
+  # Bazel's llvm-project provides LLVM libraries directly without LLD
+  if(NOT BAZEL_BUILD)
+    list(APPEND WASMEDGE_LLVM_LINK_STATIC_COMPONENTS
+      ${LLD_LIBRARY_DIR}/liblldELF.a
+      ${LLD_LIBRARY_DIR}/liblldCommon.a
+    )
+  endif()
   foreach(LIB_NAME IN LISTS WASMEDGE_LLVM_LINK_LIBS_NAME)
     list(APPEND WASMEDGE_LLVM_LINK_STATIC_COMPONENTS
       ${LLVM_LIBRARY_DIR}/lib${LIB_NAME}.a
@@ -244,20 +274,24 @@ if((WASMEDGE_LINK_LLVM_STATIC OR WASMEDGE_BUILD_STATIC_LIB) AND WASMEDGE_USE_LLV
   endforeach()
   if(LLVM_VERSION_MAJOR LESS_EQUAL 13)
     # For LLVM <= 13
-    list(APPEND WASMEDGE_LLVM_LINK_STATIC_COMPONENTS
-      ${LLD_LIBRARY_DIR}/liblldCore.a
-      ${LLD_LIBRARY_DIR}/liblldDriver.a
-      ${LLD_LIBRARY_DIR}/liblldReaderWriter.a
-      ${LLD_LIBRARY_DIR}/liblldYAML.a
-    )
+    if(NOT BAZEL_BUILD)
+      list(APPEND WASMEDGE_LLVM_LINK_STATIC_COMPONENTS
+        ${LLD_LIBRARY_DIR}/liblldCore.a
+        ${LLD_LIBRARY_DIR}/liblldDriver.a
+        ${LLD_LIBRARY_DIR}/liblldReaderWriter.a
+        ${LLD_LIBRARY_DIR}/liblldYAML.a
+      )
+    endif()
   else()
     # For LLVM 14
-    list(APPEND WASMEDGE_LLVM_LINK_STATIC_COMPONENTS
-      ${LLD_LIBRARY_DIR}/liblldMinGW.a
-      ${LLD_LIBRARY_DIR}/liblldCOFF.a
-      ${LLD_LIBRARY_DIR}/liblldMachO.a
-      ${LLD_LIBRARY_DIR}/liblldWasm.a
-    )
+    if(NOT BAZEL_BUILD)
+      list(APPEND WASMEDGE_LLVM_LINK_STATIC_COMPONENTS
+        ${LLD_LIBRARY_DIR}/liblldMinGW.a
+        ${LLD_LIBRARY_DIR}/liblldCOFF.a
+        ${LLD_LIBRARY_DIR}/liblldMachO.a
+        ${LLD_LIBRARY_DIR}/liblldWasm.a
+      )
+    endif()
   endif()
   if(LLVM_VERSION_MAJOR GREATER_EQUAL 15)
     # For LLVM 15 or greater on MacOS, or all LLVM 16+
diff --git a/include/CMakeLists.txt b/include/CMakeLists.txt
index 1c9bd74..9a703cb 100644
--- a/include/CMakeLists.txt
+++ b/include/CMakeLists.txt
@@ -39,6 +39,8 @@ configure_file(common/enum_configure.h api/wasmedge/enum_configure.h COPYONLY)
 configure_file(common/enum_errcode.h api/wasmedge/enum_errcode.h COPYONLY)
 configure_file(common/enum_types.h api/wasmedge/enum_types.h COPYONLY)
 configure_file(common/version.h.in common/version.h)
+install(DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/api/wasmedge
+        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
 unset(WASMEDGE_VERSION_STRING)
 unset(WASMEDGE_VERSION_LIST)
 unset(WASMEDGE_VERSION_MAJOR)
diff --git a/lib/api/CMakeLists.txt b/lib/api/CMakeLists.txt
index cfc8cbc..5b5f9f2 100644
--- a/lib/api/CMakeLists.txt
+++ b/lib/api/CMakeLists.txt
@@ -151,8 +151,15 @@ if(WASMEDGE_BUILD_SHARED_LIB)
 endif()
 
 if(WASMEDGE_BUILD_STATIC_LIB)
-  wasmedge_add_static_lib_component_command(fmt::fmt)
-  wasmedge_add_static_lib_component_command(spdlog::spdlog)
+  # When using Bazel, skip packaging fmt/spdlog into libwasmedge.a
+  # Bazel will handle linking these dependencies directly from the deps attribute
+  # This allows fmt to be either static or shared, and avoids the need to extract
+  # object files from libraries (which fails for shared libraries)
+  if(NOT DEFINED ENV{EXT_BUILD_DEPS})
+    # In non-Bazel builds, package fmt and spdlog into the static library
+    wasmedge_add_static_lib_component_command(fmt::fmt)
+    wasmedge_add_static_lib_component_command(spdlog::spdlog)
+  endif()
   wasmedge_add_static_lib_component_command(wasmedgeSystem)
   wasmedge_add_static_lib_component_command(wasmedgeCommon)
   wasmedge_add_static_lib_component_command(wasmedgePO)
@@ -169,9 +176,13 @@ if(WASMEDGE_BUILD_STATIC_LIB)
   wasmedge_add_static_lib_component_command(wasmedgeDriver)
 
   if(WASMEDGE_USE_LLVM)
-    foreach(LIB_NAME IN LISTS WASMEDGE_LLVM_LINK_STATIC_COMPONENTS)
-      wasmedge_add_libs_component_command(${LIB_NAME})
-    endforeach()
+    # When using Bazel, skip packaging LLVM static libraries into libwasmedge.a
+    # Bazel will handle linking LLVM libraries directly via the deps attribute
+    if(NOT BAZEL_BUILD)
+      foreach(LIB_NAME IN LISTS WASMEDGE_LLVM_LINK_STATIC_COMPONENTS)
+        wasmedge_add_libs_component_command(${LIB_NAME})
+      endforeach()
+    endif()
     wasmedge_add_static_lib_component_command(utilBlake3)
     wasmedge_add_static_lib_component_command(wasmedgeAOT)
     wasmedge_add_static_lib_component_command(wasmedgeLLVM)
diff --git a/lib/llvm/CMakeLists.txt b/lib/llvm/CMakeLists.txt
index 87e8d19..0791d8e 100644
--- a/lib/llvm/CMakeLists.txt
+++ b/lib/llvm/CMakeLists.txt
@@ -6,7 +6,13 @@ list(APPEND CMAKE_MODULE_PATH "${LLVM_CMAKE_DIR}")
 include(LLVMConfig)
 include(AddLLVM)
 
-find_package(LLD HINTS "${LLD_CMAKE_PATH}" "${LLD_DIR}" "${LLVM_LIBRARY_DIR}/cmake/lld")
+# When building with Bazel, skip LLD - Bazel provides LLVM libraries directly
+# LLD is not needed for static LLVM linking via Bazel's llvm-project
+if(NOT BAZEL_BUILD)
+  find_package(LLD HINTS "${LLD_CMAKE_PATH}" "${LLD_DIR}" "${LLVM_LIBRARY_DIR}/cmake/lld")
+else()
+  message(STATUS "Bazel build: Skipping LLD find_package (not required for Bazel-provided LLVM)")
+endif()
 if(LLD_FOUND)
   list(APPEND CMAKE_MODULE_PATH "${LLD_CMAKE_DIR}")
 endif()
